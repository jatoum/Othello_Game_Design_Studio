/*globals define, WebGMEGlobal*/
/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Fri Jul 21 2023 22:01:49 GMT-0500 (Central Daylight Time).
 */

/*globals define, WebGMEGlobal*/
/**
 * Adapted for Othello game based on the provided meta model.
 */

define([
    'js/Constants',
    'js/Utils/GMEConcepts',
    'js/NodePropertyNames',
    'Othello_Game_Design_Studio/constants' 
], function (
    CONSTANTS,
    GMEConcepts,
    nodePropertyNames,
    OTHELLO_CONSTANTS
) {

    'use strict';

    function OthelloControl(options) {
        this._logger = options.logger.fork('Control');
        this._client = options.client;

        this._currentNodeId = null;
        this._currentNodeParentId = undefined;
        this._updateWidget = null;
        this._descriptor = null;

        this._logger.debug('ctor finished');
    }

    OthelloControl.prototype.registerUpdate = function (func) {
        this._updateWidget = func;
        if (this._descriptor) {
            this._updateWidget(this._descriptor);
        }
    };

    OthelloControl.prototype.selectedObjectChanged = function (nodeId) {
        const {_logger, _client} = this;

        _logger.debug('activeObject nodeId \'' + nodeId + '\'');

        if (this._currentNodeId) {
            _client.removeUI(this._territoryId);
        }

        this._currentNodeId = nodeId;
        this._currentNodeParentId = _client.getNode(this._currentNodeId).getParentId();

        if (typeof this._currentNodeId === 'string') {
            this._selfPatterns = {};
            this._selfPatterns[this._currentNodeId] = {children: 3};

            this._territoryId = _client.addUI(this, events => {
                this._eventCallback(events);
            });

            _client.updateTerritory(this._territoryId, this._selfPatterns);
        }
    };

    OthelloControl.prototype._eventCallback = function (events) {
        this._logger.debug('_eventCallback \'' + events.length + '\' items');
        if (events[0] && events[0].etype === 'complete') {
            this._createDescriptor();
        }
        this._logger.debug('_eventCallback - DONE');
    };

    OthelloControl.prototype._createDescriptor = function () {
        const {_client, _currentNodeId, _logger} = this;
        if (typeof _currentNodeId === 'string') {
            // Get the node representing the current game state
            const node = _client.getNode(_currentNodeId);
            
            // Fetch the attributes of the game state
            const currentPlayer = node.getAttribute('CurrentPlayer');
            const lastPieceColor = node.getAttribute('LastPieceColor');
            const lastPiecePlaced = node.getAttribute('LastPiecePlaced');
            
            // Build the descriptor object based on the fetched attributes
            this._descriptor = {
                currentNodeId: _currentNodeId,
                currentPlayer: currentPlayer,
                lastPieceColor: lastPieceColor,
                lastPiecePlaced: lastPiecePlaced,
                // Additional attributes and children can be added here
            };
    
            // If a widget update function is registered, call it with the new descriptor
            if(this._updateWidget) {
                this._updateWidget(this._descriptor);
            }
        } else {
            _logger.error('Current node ID is not set.');
        }
    };
    
    OthelloControl.prototype.playerMoves = function (player, position) {
        const {_client, _currentNodeId, _logger} = this;
        if (typeof _currentNodeId === 'string') {
            // Start a transaction to make changes to the model
            _client.startTransaction('Player move');
    
            // Fetch the Tile node based on the position
            const tileNode = this._getTileNode(position);
            if (!tileNode) {
                _logger.error('Tile node not found for the position:', position);
                _client.completeTransaction();
                return;
            }
    
            // Perform the move logic, including flipping opponent pieces
            // This is pseudo-code; you'll need to implement the actual logic based on your game rules
            this._makeMove(tileNode, player);
    
            // Complete the transaction
            _client.completeTransaction();
            
            // Update the descriptor after the move
            this._createDescriptor();
        } else {
            _logger.error('Current node ID is not set.');
        }
    };

    // Helper function to get the Tile node based on position
    OthelloControl.prototype._getTileNode = function (position) {
        // Pseudo-code: Retrieve the Tile node using the WebGME API
        // Assuming 'position' is an object with 'row' and 'column'
        const boardNode = this._client.getNode(this._currentNodeId).getChildByName('Board');
        const tiles = boardNode.getChildrenNodes();
        return tiles.find(tile => tile.getAttribute('row') === position.row &&
                                  tile.getAttribute('column') === position.column);
    };

    // Helper function to make a move
    OthelloControl.prototype._makeMove = function (tileNode, player) {
        //  Update the model to reflect the move
        // This includes flipping opponent pieces
        // 'player' is assumed to be the color of the player making the move ('black' or 'white')

        // Set the piece on the chosen tile
        this._client.setAttribute(tileNode.getId(), 'color', player);

        // Determine the opponent's color
        const opponent = player === 'black' ? 'white' : 'black';

        // For each direction, check if there are pieces to flip
        const directions = [
            { dr: -1, dc: 0 },  // up
            { dr: 1,  dc: 0 },  // down
            { dr: 0,  dc: -1 }, // left
            { dr: 0,  dc: 1 },  // right
            { dr: -1, dc: -1 }, // up-left
            { dr: -1, dc: 1 },  // up-right
            { dr: 1,  dc: -1 }, // down-left
            { dr: 1,  dc: 1 }   // down-right
        ];

        directions.forEach(direction => {
            // Check for flippable pieces in this direction
            //  Use a method that returns the tiles to flip based on the rules of Othello
            const tilesToFlip = this._findFlippableTiles(tileNode, direction, player, opponent);
            // Flip the tiles
            tilesToFlip.forEach(tile => {
                this._client.setAttribute(tile.getId(), 'color', player);
            });
        });
    };

    OthelloControl.prototype._findFlippableTiles = function (tileNode, direction, player, opponent) {
        let tilesToFlip = [];
        let currentTile = tileNode;
        let row = currentTile.getAttribute('row');
        let column = currentTile.getAttribute('column');
    
        // Move to the next tile in the direction
        row += direction.dr;
        column += direction.dc;
    
        // Traverse the tiles in the direction until we hit a non-opponent piece or the edge of the board
        while (this._isValidPosition(row, column)) {
            currentTile = this._getTileNode({ row: row, column: column });
    
            // If we find a player's piece and there are opponent pieces to flip, break the loop
            if (currentTile.getAttribute('color') === player && tilesToFlip.length > 0) {
                break;
            }
            // If we find an opponent's piece, add it to the list of flippable tiles
            else if (currentTile.getAttribute('color') === opponent) {
                tilesToFlip.push(currentTile);
            }
            // If we find an empty tile or reach the edge, clear the list and break the loop
            else {
                tilesToFlip = [];
                break;
            }
    
            // Move to the next tile
            row += direction.dr;
            column += direction.dc;
        }
    
        // Return the list of tiles to flip
        return tilesToFlip;
    };
    
    // Helper function to check if a position is valid (within the bounds of the board)
    OthelloControl.prototype._isValidPosition = function (row, column) {
        return row >= 0 && row < this._boardSize && column >= 0 && column < this._boardSize;
    };    

    OthelloControl.prototype._stateActiveObjectChanged = function (model, activeObjectId) {
        if (this._currentNodeId !== activeObjectId) {
            this.selectedObjectChanged(activeObjectId);
        }
    };

    OthelloControl.prototype.destroy = function () {
        this._detachClientEventListeners();
        this._updateWidget = null;
    };

    OthelloControl.prototype._attachClientEventListeners = function () {
        this._detachClientEventListeners();
        WebGMEGlobal.State.on('change:' + CONSTANTS.STATE_ACTIVE_OBJECT, this._stateActiveObjectChanged, this);
    };

    OthelloControl.prototype._detachClientEventListeners = function () {
        WebGMEGlobal.State.off('change:' + CONSTANTS.STATE_ACTIVE_OBJECT, this._stateActiveObjectChanged);
    };

    OthelloControl.prototype.onActivate = function () {
        this._attachClientEventListeners();
        if (typeof this._currentNodeId === 'string') {
            const nodeId = this._currentNodeId;
            this._currentNodeId = null;
            WebGMEGlobal.State.registerActiveObject(nodeId, {suppressVisualizerFromNode: true});
        }
    };

    OthelloControl.prototype.onDeactivate = function () {
        this._detachClientEventListeners();
        this._updateWidget = null;
    };

    return OthelloControl;
});
